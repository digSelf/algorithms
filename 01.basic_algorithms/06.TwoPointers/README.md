# 双指针算法

## 双指针枚举区间

先枚举终点，再枚举起点；终点和起点的位置可以相等，因为区间内可以有一个元素。

**朴素模板**：

```cpp
for (int r = 0; r < n; ++r) {
    for (int l = 0; l <= r; ++l) {
        if (check(l, r)) {
            // blablabla...
        }
    }
}
```

找到所维护的区间断点的关系后的优化写法：

```cpp
for (int l = 0, r = 0; r < n; ++r) { // 先枚举终点
    while (l <= r && check(l, r)) { // 再枚举起点，且终点和起点可以相等，即：可以只有一个元素
        // **NOTICE** 注意：这个check函数是用来控制，在满足什么性质的条件下，左端点指针l向前移动。
        ++l;
    }
    // blablabla...
}
```



## 例题

### 最长连续不重复子序列

给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数（均在 0∼10^5 范围内），表示整数序列。

#### 输出格式

共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

#### 数据范围

`1 <= n <= 10^5`

#### 输入样例：

```
5
1 2 2 3 5
```

#### 输出样例：

```
3
```

#### 所在文件

* `the_max_length_subsequence_tpl`

### 数组元素的目标和

给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。

数组下标从 0 开始。

请你求出满足 A[i]+B[j]=x 的数对 (i,j)。

数据保证有唯一解。

#### 输入格式

第一行包含三个整数 n,m,x，分别表示 AA的长度，B 的长度以及目标值x。

第二行包含 n 个整数，表示数组 A。

第三行包含 m 个整数，表示数组 B。

#### 输出格式

共一行，包含两个整数 i 和 j。

#### 数据范围

* 数组长度不超过 `10^5`
* 同一数组内元素各不相同。
* `1 <= 数组元素 <= 10^9`

#### 输入样例：

```
4 5 6
1 2 4 7
3 4 6 8 9
```

#### 输出样例：

```
1 1
```

#### 所在文件

* `elem_sum_target.cpp`

### 判断子序列

给定一个长度为 n 的整数序列 `a1,a2,…,an` 以及一个长度为 m 的整数序列 `b1,b2,…,bm。`

请你判断 a 序列是否为 b 序列的子序列。

子序列指序列的一部分项按**原有次序排列**而得的序列，例如序列 `{a1,a3,a5}` 是序列 `{a1,a2,a3,a4,a5}` 的一个子序列。

#### 输入格式

第一行包含两个整数 n,m。·

第二行包含 n 个整数，表示`a1,a2,…,an` 。

第三行包含 m 个整数，表示`b1,b2,…,bm`。

#### 输出格式

如果 a 序列是 b 序列的子序列，输出一行 `Yes`。

否则，输出 `No`。

#### 数据范围

* `1 <= n<= m <= 10^5`
* `−10^9 <= ai,bi <= 10^9`

#### 输入样例：

```
3 5
1 3 5
1 2 3 4 5
```

#### 输出样例：

```
Yes
```
